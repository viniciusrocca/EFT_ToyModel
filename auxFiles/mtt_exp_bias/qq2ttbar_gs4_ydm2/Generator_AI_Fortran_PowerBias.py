import numpy as np
from sklearn.linear_model import LinearRegression
from sklearn.multioutput import MultiOutputRegressor
import matplotlib.pyplot as plt

# ==============================================================================
# 1. THE TRAINING DATABASE
# ==============================================================================
# Format: [Mass_Psi, Mass_S]
X_train = np.array([
    [1000.0, 500.0],
    [725.0,  675.0],
    [500.0,  475.0],
    [1500.0, 1425.0], # Assumed typo in Bound2 fixed (using Ex 7 logic)
    [1300.0, 1200.0],
    [900.0,  600.0],
    [1500.0, 1000.0]
])

# Format: [Bound1, Bound2, Ref1, Ref2, Ref3, Alpha1]
# Note: Alpha2 (2.0) and Alpha3 (8.0) are constant in your data, so we don't predict them.
# We predict Bound2 for (1500,1425) based on the (1500,1000) example.
y_train = np.array([
    [2101.0, 2501.0, 2500.0, 1700.0, 2000.0, 3.0], # 1000, 500
    [1601.0, 1801.0, 1800.0, 1500.0, 1550.0, 3.0], # 725, 675
    [1051.0, 1201.0, 1200.0, 1034.0, 1150.0, 3.0], # 500, 475
    [3510.0, 3770.0, 3100.0, 3104.0, 3207.0, 3.3], # 1500, 1425
    [2868.0, 3228.0, 3227.0, 2690.0, 2780.0, 3.0], # 1300, 1200
    [1986.0, 2235.0, 2300.0, 1862.0, 1924.0, 3.0], # 900, 600
    [3510.0, 3770.0, 3100.0, 3104.0, 3207.0, 3.3]  # 1500, 1000
])

# ==============================================================================
# 2. TRAIN THE MODEL
# ==============================================================================
# We use Linear Regression because physics scaling is usually linear/polynomial.
# With so few points, Random Forest would likely overfit or be "jumpy".
model = MultiOutputRegressor(LinearRegression())
model.fit(X_train, y_train)

print("AI Training Complete.")
print(f"R2 Score: {model.score(X_train, y_train):.4f} (Accuracy on training set)")

# ==============================================================================
# 3. PREDICTION & CODE GENERATION FUNCTION
# ==============================================================================
def generate_bias_code(mass_psi, mass_s):
    # Predict parameters
    inputs = np.array([[mass_psi, mass_s]])
    preds = model.predict(inputs)[0]
    
    b1, b2, r1, r2, r3, a1 = preds
    
    # Constants observed in your data
    a2 = 2.0
    a3 = 8.0
    
    # Formatting the Fortran code
    code = f"""
c     --- BIAS GENERATED BY AI FOR POINT ({mass_psi}, {mass_s}) ---
      if (mtt.gt.0.0d0) then
         if (mtt.lt.{b1:.1f}d0) then
            bias_wgt = (mtt/{r1:.1f}d0)**{a1:.2f}d0
         else if (mtt.lt.{b2:.1f}d0) then
            bias_wgt = (mtt/{r2:.1f}d0)**{a2:.1f}d0
         else
            bias_wgt = (mtt/{r3:.1f}d0)**{a3:.1f}d0
         endif
      endif
    """
    return code, preds

# ==============================================================================
# 4. INTERACTIVE USER INPUT
# ==============================================================================
if __name__ == "__main__":
    print("\n--- BIAS FUNCTION PREDICTOR ---")
    print("Enter the masses for your new point.")
    
    try:
        in_psi = float(input("Mass Psi (e.g. 1100): "))
        in_s   = float(input("Mass S   (e.g. 600):  "))
        
        fortran_code, params = generate_bias_code(in_psi, in_s)
        
        print("\n" + "="*40)
        print("PREDICTED PARAMETERS:")
        print(f"Boundaries: {params[0]:.1f}, {params[1]:.1f}")
        print(f"Refs:       {params[2]:.1f}, {params[3]:.1f}, {params[4]:.1f}")
        print(f"Alpha1:     {params[5]:.2f}")
        print("="*40)
        print("\nCopy this block into your Fortran code:")
        print(fortran_code)
        
        # Optional: Plot validation
        plt.figure(figsize=(8,5))
        m_test = np.linspace(500, 4000, 100)
        weights = []
        b1, b2, r1, r2, r3, a1 = params
        for m in m_test:
            if m < b1: w = (m/r1)**a1
            elif m < b2: w = (m/r2)**2.0
            else: w = (m/r3)**8.0
            weights.append(w)
            
        plt.plot(m_test, weights)
        plt.yscale('log')
        plt.title(f'Predicted Bias Shape for M={in_psi}, Ms={in_s}')
        plt.xlabel('Mtt (GeV)')
        plt.ylabel('Bias Weight')
        plt.grid(True, which="both")
        plt.savefig('predicted_bias.png')
        print("Plot generated: predicted_bias.png")
        
    except ValueError:
        print("Invalid input. Please enter numbers.")